<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simple Ping Pong (Vanilla JS)</title>
<style>
  :root {
    --bg: #0b0f19;
    --fg: #e8eefc;
    --accent: #6ea8fe;
    --muted: #2a3142;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
    color: var(--fg); background: radial-gradient(1200px 800px at 50% -200px, #172037, var(--bg));
    min-height: 100vh; display: grid; place-items: center;
  }
  .wrap {
    width: min(95vw, 900px);
  }
  header {
    display:flex; justify-content:space-between; align-items:center; gap:8px; margin: 12px 4px 8px;
  }
  h1 { font-size: 18px; margin: 0; letter-spacing: .3px; font-weight: 600; color: #dfe8ff; }
  .controls {
    display:flex; gap:8px; align-items:center; flex-wrap: wrap;
  }
  button {
    appearance:none; border:1px solid #39435b; background:#1a2135; color:#e7edff;
    padding:8px 12px; border-radius:10px; cursor:pointer; transition:transform .06s ease, background .2s;
  }
  button:hover { background:#212a44; }
  button:active { transform: translateY(1px); }
  .hint { color:#b7c3e0; font-size: 12px; opacity:.9 }
  .canvas-shell {
    position: relative;
    background: linear-gradient(180deg, #0f1527, #0b0f19);
    border: 1px solid #2a3142; border-radius: 16px; padding: 10px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.02);
  }
  canvas {
    display:block; width: 100%; height: auto; border-radius: 12px;
    background: #0b0f19;
  }
  footer { margin: 10px 4px 0; color:#9fb0d6; font-size:12px; }
  .scoreboard {
    position:absolute; left:50%; top:10px; transform:translateX(-50%);
    font-size: 28px; letter-spacing: 2px; color: #e8eefc; text-shadow: 0 2px 0 #000;
    user-select: none; pointer-events: none;
  }
  .center-line {
    position:absolute; left:50%; top:10px; bottom:10px; width: 2px; transform: translateX(-50%);
    background: repeating-linear-gradient(to bottom, rgba(255,255,255,.35) 0 10px, rgba(255,255,255,0) 10px 26px);
    filter: blur(.2px);
    pointer-events:none;
  }
  .overlay {
    position:absolute; inset:10px; display:grid; place-items:center; pointer-events:none;
    text-align:center; color:#e8eefc;
  }
  .overlay .card {
    background: rgba(9,12,22,.7);
    border: 1px solid #2a3142; border-radius:14px; padding:18px 20px; max-width: 80%;
    box-shadow: 0 8px 24px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.03);
  }
  .overlay h2 { margin:0 0 6px; font-size:18px; }
  .overlay p { margin:0; font-size:13px; color:#c6d3f3 }
  .badge {
    display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #3a4560; background:#121a2d; color:#cfe0ff; font-size:11px; margin-left:8px;
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Ping Pong <span class="badge">Vanilla JS</span></h1>
      <div class="controls">
        <button id="btnStart">Start</button>
        <button id="btnPause">Pause</button>
        <button id="btnReset">Reset</button>
        <span class="hint">W/S = left paddle · Space = pause</span>
      </div>
    </header>

    <div class="canvas-shell">
      <div class="scoreboard" id="score">0 : 0</div>
      <div class="center-line" aria-hidden="true"></div>
      <canvas id="game" width="800" height="500" aria-label="Ping Pong game area"></canvas>

      <div class="overlay" id="overlay">
        <div class="card">
          <h2>Press <strong>Start</strong> or hit <strong>Space</strong></h2>
          <p>Move with <strong>W</strong>/<strong>S</strong>. Beat the AI to 7!</p>
        </div>
      </div>
    </div>

    <footer>
      Tip: Open this file locally and play. You can tweak constants at the top of the script to change speed, paddle size, and winning score.
    </footer>
  </div>

<script>
(() => {
  // ---- Config ----
  const WIN_SCORE = 7;
  const BALL_SPEED_START = 5.2;       // initial speed (pixels per frame)
  const BALL_SPEED_INCREMENT = 0.15;  // speed added after each paddle hit
  const BALL_MAX_SPEED = 14;
  const PADDLE_HEIGHT = 90;
  const PADDLE_WIDTH  = 12;
  const PADDLE_SPEED  = 7;            // player paddle speed per frame
  const AI_MAX_SPEED  = 6.2;          // AI vertical speed cap
  const AI_REACTION   = 0.18;         // 0..1 how strongly AI chases the ball

  // ---- DOM ----
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const overlay = document.getElementById('overlay');
  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnReset = document.getElementById('btnReset');

  // ---- State ----
  const state = {
    running: false,
    paused: false,
    width: canvas.width,
    height: canvas.height,
    left: { x: 20, y: 0, w: PADDLE_WIDTH, h: PADDLE_HEIGHT },
    right:{ x: 0,  y: 0, w: PADDLE_WIDTH, h: PADDLE_HEIGHT },
    ball: { x: 0, y: 0, r: 8, vx: 0, vy: 0, speed: BALL_SPEED_START },
    keys: { up:false, down:false, w:false, s:false },
    score: { l:0, r:0 }
  };
  state.right.x = state.width - 20 - PADDLE_WIDTH;

  function resetPaddles() {
    state.left.y  = (state.height - state.left.h) / 2;
    state.right.y = (state.height - state.right.h) / 2;
  }
  function launchBall(toLeft = false) {
    const angle = (Math.random() * 0.6 - 0.3); // -0.3..0.3 rad (~-17..17 deg)
    const dir = toLeft ? -1 : 1;
    state.ball.x = state.width / 2;
    state.ball.y = state.height / 2;
    state.ball.speed = BALL_SPEED_START;
    state.ball.vx = Math.cos(angle) * state.ball.speed * dir;
    state.ball.vy = Math.sin(angle) * state.ball.speed;
    // Ensure vertical component isn't too small
    if (Math.abs(state.ball.vy) < 2) state.ball.vy = 2 * Math.sign(state.ball.vy || 1);
  }
  function resetRound(loser = 'l') {
    const serveLeft = loser === 'r';
    resetPaddles();
    launchBall(!serveLeft);
  }
  function resetGame() {
    state.score.l = 0; state.score.r = 0;
    overlay.style.display = '';
    state.paused = false;
    state.running = false;
    resetPaddles();
    draw(); // show fresh board
    updateScore();
  }
  function updateScore() {
    scoreEl.textContent = `${state.score.l} : ${state.score.r}`;
  }

  // ---- Input ----
  window.addEventListener('keydown', (e) => {
    if (e.code === 'KeyW') state.keys.w = true;
    if (e.code === 'KeyS') state.keys.s = true;
    if (e.code === 'ArrowUp') state.keys.up = true;
    if (e.code === 'ArrowDown') state.keys.down = true;
    if (e.code === 'Space') {
      e.preventDefault();
      if (!state.running) start();
      else togglePause();
    }
    if (e.code === 'KeyR') resetGame();
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'KeyW') state.keys.w = false;
    if (e.code === 'KeyS') state.keys.s = false;
    if (e.code === 'ArrowUp') state.keys.up = false;
    if (e.code === 'ArrowDown') state.keys.down = false;
  });

  // ---- Buttons ----
  btnStart.onclick = () => { if (!state.running) start(); else if (state.paused) togglePause(); };
  btnPause.onclick = togglePause;
  btnReset.onclick = resetGame;

  function start() {
    overlay.style.display = 'none';
    state.running = true;
    state.paused = false;
    resetRound(Math.random() < 0.5 ? 'l' : 'r');
    rafLoop();
  }
  function togglePause() {
    if (!state.running) return;
    state.paused = !state.paused;
    overlay.style.display = state.paused ? '' : 'none';
    overlay.querySelector('.card h2').innerHTML = state.paused ? 'Paused — press <strong>Space</strong>' : 'Press <strong>Start</strong> or hit <strong>Space</strong>';
    if (!state.paused) rafLoop();
  }

  // ---- Mechanics ----
  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
  function rectCircleCollide(rx, ry, rw, rh, cx, cy, cr) {
    const nearestX = clamp(cx, rx, rx + rw);
    const nearestY = clamp(cy, ry, ry + rh);
    const dx = cx - nearestX, dy = cy - nearestY;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  function update() {
    // Player paddle (W/S)
    if (state.keys.w) state.left.y -= PADDLE_SPEED;
    if (state.keys.s) state.left.y += PADDLE_SPEED;
    state.left.y = clamp(state.left.y, 0, state.height - state.left.h);

    // AI paddle: chase ball with limited speed & reaction
    const targetY = state.ball.y - state.right.h / 2;
    const delta = targetY - state.right.y;
    const move = clamp(delta * AI_REACTION, -AI_MAX_SPEED, AI_MAX_SPEED);
    state.right.y = clamp(state.right.y + move, 0, state.height - state.right.h);

    // Move ball
    state.ball.x += state.ball.vx;
    state.ball.y += state.ball.vy;

    // Wall bounce (top/bottom)
    if (state.ball.y - state.ball.r <= 0 && state.ball.vy < 0) {
      state.ball.y = state.ball.r;
      state.ball.vy *= -1;
    }
    if (state.ball.y + state.ball.r >= state.height && state.ball.vy > 0) {
      state.ball.y = state.height - state.ball.r;
      state.ball.vy *= -1;
    }

    // Paddle collisions
    const hitLeft = rectCircleCollide(state.left.x, state.left.y, state.left.w, state.left.h, state.ball.x, state.ball.y, state.ball.r);
    const hitRight = rectCircleCollide(state.right.x, state.right.y, state.right.w, state.right.h, state.ball.x, state.ball.y, state.ball.r);

    if (hitLeft && state.ball.vx < 0) {
      // compute bounce angle based on hit position
      const rel = (state.ball.y - (state.left.y + state.left.h / 2)) / (state.left.h / 2); // -1..1
      const angle = rel * (Math.PI / 3.5); // max ~51°
      state.ball.speed = Math.min(state.ball.speed + BALL_SPEED_INCREMENT, BALL_MAX_SPEED);
      state.ball.vx = Math.cos(angle) * state.ball.speed;
      state.ball.vy = Math.sin(angle) * state.ball.speed;
      state.ball.x = state.left.x + state.left.w + state.ball.r + 0.1; // nudge out
      ping();
    }
    if (hitRight && state.ball.vx > 0) {
      const rel = (state.ball.y - (state.right.y + state.right.h / 2)) / (state.right.h / 2);
      const angle = rel * (Math.PI / 3.5);
      state.ball.speed = Math.min(state.ball.speed + BALL_SPEED_INCREMENT, BALL_MAX_SPEED);
      state.ball.vx = -Math.cos(angle) * state.ball.speed;
      state.ball.vy = Math.sin(angle) * state.ball.speed;
      state.ball.x = state.right.x - state.ball.r - 0.1;
      ping();
    }

    // Scoring (ball past edges)
    if (state.ball.x + state.ball.r < 0) { // right scores
      state.score.r++; updateScore(); scoreChime();
      if (state.score.r >= WIN_SCORE) return endGame('AI wins!');
      resetRound('l');
    } else if (state.ball.x - state.ball.r > state.width) { // left scores
      state.score.l++; updateScore(); scoreChime();
      if (state.score.l >= WIN_SCORE) return endGame('You win!');
      resetRound('r');
    }
  }

  function endGame(text) {
    state.running = false;
    state.paused = true;
    overlay.style.display = '';
    overlay.querySelector('.card h2').textContent = text;
    overlay.querySelector('.card p').textContent = 'Press Start or R to play again.';
  }

  // ---- Render ----
  function draw() {
    const { width: w, height: h } = state;
    ctx.clearRect(0,0,w,h);

    // Court glow
    ctx.fillStyle = '#0e1426';
    ctx.fillRect(0,0,w,h);

    // Paddles
    ctx.fillStyle = '#d7e2ff';
    roundRect(ctx, state.left.x, state.left.y, state.left.w, state.left.h, 6, true);
    roundRect(ctx, state.right.x, state.right.y, state.right.w, state.right.h, 6, true);

    // Ball
    ctx.beginPath();
    ctx.arc(state.ball.x, state.ball.y, state.ball.r, 0, Math.PI*2);
    ctx.fill();

    // Subtle glow on ball
    const grad = ctx.createRadialGradient(state.ball.x, state.ball.y, 2, state.ball.x, state.ball.y, 30);
    grad.addColorStop(0, 'rgba(255,255,255,.5)');
    grad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(state.ball.x, state.ball.y, 30, 0, Math.PI*2);
    ctx.fill();
  }

  function roundRect(ctx, x, y, w, h, r, fill) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    if (fill) ctx.fill();
  }

  // ---- Loop ----
  let rafId = null;
  function rafLoop() {
    if (!state.running || state.paused) return;
    update();
    draw();
    rafId = requestAnimationFrame(rafLoop);
  }

  // ---- Tiny sounds (WebAudio, lightweight) ----
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  function ensureAudio() { if (!audioCtx) audioCtx = new AudioCtx(); }
  function ping() { try {
    ensureAudio();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square'; o.frequency.value = 520;
    g.gain.value = 0.04;
    o.connect(g).connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + 0.06);
  } catch(_){} }
  function scoreChime() { try {
    ensureAudio();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'triangle'; o.frequency.value = 660;
    g.gain.value = 0.05;
    o.connect(g).connect(audioCtx.destination);
    o.start();
    o.frequency.exponentialRampToValueAtTime(440, audioCtx.currentTime + 0.18);
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.2);
    o.stop(audioCtx.currentTime + 0.22);
  } catch(_){} }

  // Initial paint
  resetGame();
})();
</script>
</body>
</html>
