<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Checkers with AI — Single File</title>
<style>
  :root{
    --bg: #0f1221;
    --card: #151935;
    --accent: #7c9cff;
    --accent-2: #22c55e;
    --red: #ef4444;
    --dark: #1f273a;
    --light: #e5e7eb;
    --square-dark: #3a456b; /* playable squares */
    --square-light: #c7d2fe22; /* non-playable */
    --highlight: #fde047; /* yellow */
    --ghost: #ffffff22;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji","Segoe UI Emoji";
    background: radial-gradient(1000px 600px at 20% -10%, #1e223f, var(--bg));
    color: var(--light);
    min-height:100dvh;
    display:grid; place-items:center; padding:24px;
  }
  .app{
    width:min(1100px, 100%);
    display:grid; grid-template-columns: 1fr 360px; gap:24px;
  }
  @media (max-width: 960px){
    .app{grid-template-columns: 1fr;}
  }
  .card{
    background: linear-gradient(180deg, var(--card), #0f1430);
    border:1px solid #2a3263; border-radius:20px; padding:16px; box-shadow: 0 10px 30px #00000044;
  }
  h1{font-size: clamp(20px, 2.2vw, 28px); margin:0 0 12px; font-weight:700;}
  .sub{opacity:.8; font-size:14px; margin-bottom:12px}

  /* Board */
  .board-wrap{display:grid; place-items:center}
  .board{ width:min(90vmin, 720px); aspect-ratio:1/1; display:grid; grid-template-columns: repeat(8, 1fr); border-radius:18px; overflow:hidden; border: 1px solid #2f3870; box-shadow: inset 0 0 0 1px #00000033;
    background: #222a4d;
  }
  .sq{ position:relative; width:100%; padding-top:100%; }
  .sq > .inner{ position:absolute; inset:0; display:grid; place-items:center; }
  .sq.dark{ background: var(--square-dark); }
  .sq.light{ background: var(--square-light); }
  .coord{ position:absolute; font-size:10px; opacity:.35; left:6px; top:4px; }

  /* Piece */
  .piece{ width:76%; aspect-ratio:1/1; border-radius:50%; display:grid; place-items:center; cursor:pointer; user-select:none; transition: transform .08s ease, box-shadow .2s ease; box-shadow: 0 6px 10px #0006, inset 0 1px 0 #ffffff33; }
  .piece.red{ background: linear-gradient(180deg, #ff6b6b, #c81e1e); border:1px solid #8f1b1b; }
  .piece.black{ background: linear-gradient(180deg, #9eb6ff, #334155); border:1px solid #1f2937; }
  .piece.king::after{ content:"♛"; font-size: 22px; filter: drop-shadow(0 2px 1px #000a); }
  .piece:hover{ transform: translateY(-2px); }
  .dim{ opacity:.55; pointer-events:none }

  /* Highlights */
  .sq.move{ outline: 3px solid var(--accent); outline-offset:-3px; }
  .sq.capture{ outline: 3px solid var(--accent-2); outline-offset:-3px; }
  .ghost{ position:absolute; inset:14%; border-radius:50%; background: var(--ghost); box-shadow: inset 0 0 0 2px #ffffff55; }
  .selected{ box-shadow: 0 0 0 4px #fde04799, 0 6px 10px #0008 !important; }

  /* Sidebar */
  .side{ display:flex; flex-direction:column; gap:12px; }
  .row{ display:flex; align-items:center; gap:10px; justify-content:space-between }
  label{ font-size:14px; opacity:.9 }
  select, button{ background:#11152b; color:#e5e7eb; border:1px solid #2a3263; padding:10px 12px; border-radius:12px; font-weight:600; cursor:pointer }
  select{ width: 180px; }
  button.primary{ background: linear-gradient(180deg, #5b7cff, #384cff); border-color:#5063ff; }
  button.warn{ background: linear-gradient(180deg, #ef4444, #b91c1c); border-color:#7f1d1d; }
  .status{ padding:12px; border-radius:12px; background:#0c1126; border:1px solid #2a3263; min-height:48px; display:grid; align-content:center; }
  .legend{ display:flex; gap:8px; align-items:center; font-size:13px; opacity:.9 }
  .dot{ width:14px; height:14px; border-radius:50%; display:inline-block; vertical-align:middle }
  .dot.red{ background: linear-gradient(180deg, #ff6b6b, #c81e1e); border:1px solid #8f1b1b; }
  .dot.black{ background: linear-gradient(180deg, #9eb6ff, #334155); border:1px solid #1f2937; }
  .sm{ font-size:12px; opacity:.85 }
  .hr{ height:1px; background:#2a3263; margin:6px 0 8px }
  .small{ font-size:12px; opacity:.8 }
  details{ background:#0c1126; border:1px solid #2a3263; border-radius:12px; padding:10px }
  details pre{ margin:8px 0 0; max-height:220px; overflow:auto; font-size:12px; }
</style>
</head>
<body>
  <div class="app">
    <div class="card board-wrap">
      <h1>Checkers</h1>
      <div class="sub">Play against a built‑in AI. You move first.</div>
      <div id="board" class="board" aria-label="Checkers board (8 by 8)"></div>
    </div>
    <div class="card side">
      <div class="row">
        <label for="sideSel">Your side</label>
        <select id="sideSel">
          <option value="1">Black (goes first)</option>
          <option value="-1">Red</option>
        </select>
      </div>
      <div class="row">
        <label for="diffSel">Difficulty</label>
        <select id="diffSel">
          <option value="4">Easy</option>
          <option value="6" selected>Medium</option>
          <option value="8">Hard</option>
        </select>
      </div>
      <div class="row">
        <button id="newBtn" class="primary">New game</button>
        <button id="undoBtn">Undo</button>
      </div>
      <div class="status" id="status">Ready.</div>
      <div class="hr"></div>
      <div class="legend"><span class="dot black"></span> You &nbsp;<span class="dot red"></span> AI</div>
      <div class="small">Rules: Mandatory captures, multi‑jump, kinging on last rank. In American rules, if a man reaches king row during a capture, the move ends.</div>
      <div class="hr"></div>
      <details>
        <summary><strong>Built‑in tests</strong> (click to view log)</summary>
        <div class="row" style="margin:8px 0 6px 0; gap:8px; justify-content:flex-start">
          <button id="runTests">Run tests</button>
        </div>
        <pre id="testLog">(auto‑run on load)</pre>
      </details>
    </div>
  </div>

<script>
(()=>{
  // Piece encoding: 0 empty; 1 black man; 2 black king; -1 red man; -2 red king
  const BLACK = 1, RED = -1, KING = 2;

  const boardEl = document.getElementById('board');
  const statusEl = document.getElementById('status');
  const sideSel = document.getElementById('sideSel');
  const diffSel = document.getElementById('diffSel');
  const newBtn = document.getElementById('newBtn');
  const undoBtn = document.getElementById('undoBtn');
  const runTestsBtn = document.getElementById('runTests');
  const testLog = document.getElementById('testLog');

  let state = {
    board: null,
    turn: BLACK,
    human: BLACK,
    history: [],
    searching: false,
    depth: 6
  };

  const deepClone = (o)=> JSON.parse(JSON.stringify(o));
  function cloneBoard(b){ return b.map(r=>r.slice()); }

  function startPosition(){
    const b = [...Array(8)].map(()=>Array(8).fill(0));
    for(let r=0;r<3;r++){
      for(let c=0;c<8;c++) if((r+c)%2===1) b[r][c] = RED; // top are red
    }
    for(let r=5;r<8;r++){
      for(let c=0;c<8;c++) if((r+c)%2===1) b[r][c] = BLACK; // bottom are black
    }
    return b;
  }

  function isDark(r,c){ return (r+c)%2===1; }

  // Directions per side
  const DIRS = {
    [BLACK]: [[-1,-1],[-1,1]], // moves up rows
    [RED]: [[1,-1],[1,1]],
  };
  const ALLDIRS = [[-1,-1],[-1,1],[1,-1],[1,1]];

  function isKing(p){ return Math.abs(p)===KING; }
  function sideOf(p){ return p>0?BLACK:RED; }

  // Generate all legal moves for player (BLACK or RED). Each move is an object {seq:[{r,c},...], captured:[{r,c,p},...]}
  function generateMoves(board, player){
    const captures = [];
    const quiets = [];

    function addQuietMove(from, to){
      quiets.push({ seq:[from, to], captured:[] });
    }
    function addCaptureMove(seq, captured){
      captures.push({ seq: deepClone(seq), captured: deepClone(captured) });
    }

    // DFS for capture chains — IMPORTANT: pass mutated board through recursion
    function captureDFS(curBoard, r, c, piece, seq, captured){
      let progressed = false;
      const king = isKing(piece);
      const dirs = king? ALLDIRS : DIRS[ sideOf(piece) ];

      for(const [dr,dc] of dirs){
        const r1=r+dr, c1=c+dc, r2=r+2*dr, c2=c+2*dc;
        if(r2<0||r2>7||c2<0||c2>7||r1<0||r1>7||c1<0||c1>7) continue;
        if(curBoard[r1][c1]!==0 && sideOf(curBoard[r1][c1])===-sideOf(piece) && curBoard[r2][c2]===0){
          // simulate capture
          const b2 = cloneBoard(curBoard);
          b2[r][c]=0; b2[r1][c1]=0; let np = piece;
          // kinging check — American rules: if a man reaches king row during the jump, it becomes king and the move ends
          const landedR = r2;
          if(!king){
            if(sideOf(piece)===BLACK && r2===0){ np = KING; }
            else if(sideOf(piece)===RED && r2===7){ np = -KING; }
          }
          b2[r2][c2]=np;
          const seq2 = [...seq, {r:r2,c:c2}];
          const cap2 = [...captured, {r:r1,c:c1,p:curBoard[r1][c1]}];

          if(!king && Math.abs(np)===KING){
            // If the piece just kinged mid-jump, chain ends here (American rules)
            addCaptureMove(seq2, cap2);
            progressed = true;
          } else {
            // continue searching for additional captures from new square
            let before = captures.length;
            captureDFS(b2, r2, c2, np, seq2, cap2);
            // if no further captures were added in deeper levels, record current chain
            if(captures.length===before){ addCaptureMove(seq2, cap2); }
            progressed = true;
          }
        }
      }

      // Base case: if no progress and we have captured something, push the chain
      if(!progressed && captured.length>0){ addCaptureMove(seq, captured); }
    }

    // Search captures from every piece of the player
    for(let r=0;r<8;r++) for(let c=0;c<8;c++){
      const p = board[r][c];
      if(p===0 || sideOf(p)!==player) continue;
      captureDFS(board, r, c, p, [{r,c}], []);
    }

    if(captures.length>0) return captures; // mandatory captures

    // Quiet moves
    for(let r=0;r<8;r++) for(let c=0;c<8;c++){
      const p = board[r][c];
      if(p===0 || sideOf(p)!==player) continue;
      const king = isKing(p);
      const dirs = king? ALLDIRS : DIRS[player];
      for(const [dr,dc] of dirs){
        const r1=r+dr, c1=c+dc;
        if(r1<0||r1>7||c1<0||c1>7) continue;
        if(board[r1][c1]===0){ addQuietMove({r,c}, {r:r1,c:c1}); }
      }
    }
    return quiets;
  }

  function applyMove(board, move){
    const b = cloneBoard(board);
    const seq = move.seq;
    const from = seq[0];
    const to = seq[seq.length-1];
    let p = b[from.r][from.c];
    b[from.r][from.c]=0;
    // remove captured
    for(const cap of move.captured){ b[cap.r][cap.c]=0; }
    // handle kinging
    if(!isKing(p)){
      if(sideOf(p)===BLACK && to.r===0) p = KING;
      if(sideOf(p)===RED && to.r===7) p = -KING;
    }
    b[to.r][to.c]=p;
    return b;
  }

  // Evaluation
  function evaluate(board){
    let score=0, bm=0, rk=0, bk=0, rm=0, mobility=0;
    for(let r=0;r<8;r++) for(let c=0;c<8;c++){
      const p = board[r][c]; if(!p) continue;
      const val = isKing(p)? 5 : 3;
      const pos = 0.1 * ( (p>0? (7-r) : r) ); // advancing bonus
      const center = (c>=2&&c<=5 && r>=2&&r<=5)? 0.15:0;
      const pieceScore = (val + pos + center) * (p>0?1:-1);
      score += pieceScore;
      if(p>0){ if(isKing(p)) bk++; else bm++; } else { if(isKing(p)) rk++; else rm++; }
    }
    // mobility (cheap heuristic)
    mobility += 0.03 * (generateMoves(board, BLACK).length - generateMoves(board, RED).length);
    score += mobility;
    // Endgame weight for kings
    if(bm+rm+bk+rk <= 8) score += 0.2 * (bk - rk);
    return score;
  }

  // Minimax with alpha-beta
  function search(board, player, depth, alpha, beta){
    const moves = generateMoves(board, player);
    if(depth===0 || moves.length===0){
      return { score: evaluate(board), move: null };
    }
    let best=null;
    if(player===BLACK){
      let maxEval = -Infinity;
      // move ordering: captures first already; small heuristic: prefer longer sequences
      moves.sort((a,b)=> b.captured.length - a.captured.length);
      for(const m of moves){
        const b2 = applyMove(board, m);
        const {score} = search(b2, -player, depth-1, alpha, beta);
        if(score>maxEval){ maxEval=score; best=m; }
        alpha = Math.max(alpha, score);
        if(beta<=alpha) break;
      }
      return { score:maxEval, move:best };
    } else {
      let minEval = Infinity;
      moves.sort((a,b)=> b.captured.length - a.captured.length);
      for(const m of moves){
        const b2 = applyMove(board, m);
        const {score} = search(b2, -player, depth-1, alpha, beta);
        if(score<minEval){ minEval=score; best=m; }
        beta = Math.min(beta, score);
        if(beta<=alpha) break;
      }
      return { score:minEval, move:best };
    }
  }

  // UI rendering
  function render(){
    boardEl.innerHTML='';
    for(let r=0;r<8;r++) for(let c=0;c<8;c++){
      const sq = document.createElement('div');
      sq.className = 'sq ' + (isDark(r,c)?'dark':'light');
      const inner = document.createElement('div');
      inner.className='inner';
      if(c===0){ // show coordinates (rows on left)
        const coord = document.createElement('div');
        coord.className='coord';
        coord.textContent = 8-r;
        inner.appendChild(coord);
      }
      // pieces
      const p = state.board[r][c];
      if(p!==0){
        const piece = document.createElement('div');
        piece.className = 'piece ' + (p>0? 'black':'red') + (isKing(p)? ' king':'');
        piece.dataset.r=r; piece.dataset.c=c;
        if(state.turn!==state.human || state.searching) piece.classList.add('dim');
        piece.addEventListener('click', onPieceClick);
        inner.appendChild(piece);
      }
      sq.appendChild(inner);
      sq.dataset.r=r; sq.dataset.c=c;
      sq.addEventListener('click', onSquareClick);
      boardEl.appendChild(sq);
    }
    updateHighlights();
  }

  // Interaction state
  let selected = null; // {r,c}
  let legalForSelected = []; // subset of moves starting at selected
  let allLegal = [];

  function updateStatus(text){ statusEl.textContent = text; }

  function updateHighlights(){
    const children = boardEl.children;
    for(const el of children){ el.classList.remove('move','capture'); const g=el.querySelector('.ghost'); if(g) g.remove(); }
    if(!selected){ return; }
    // highlight selected
    const idx = (r,c)=> r*8+c;
    const sel = children[idx(selected.r, selected.c)];
    if(sel){ const pieceEl = sel.querySelector('.piece'); if(pieceEl) pieceEl.classList.add('selected'); }
    // show destinations
    const targets = new Map(); // key r,c -> capture count
    for(const m of legalForSelected){ const last = m.seq[m.seq.length-1];
      const key=last.r+','+last.c;
      targets.set(key, Math.max(targets.get(key)||0, m.captured.length));
    }
    for(const [key,capCount] of targets){
      const [r,c] = key.split(',').map(Number);
      const el = children[idx(r,c)];
      if(!el) continue;
      el.classList.add(capCount>0? 'capture':'move');
      const gh = document.createElement('div'); gh.className='ghost'; el.appendChild(gh);
    }
  }

  function onPieceClick(e){
    if(state.searching) return;
    const r=+e.currentTarget.dataset.r, c=+e.currentTarget.dataset.c;
    if(state.turn!==state.human) return;
    if(sideOf(state.board[r][c])!==state.human) return;
    selectSquare(r,c);
  }

  function onSquareClick(e){
    if(state.searching) return;
    if(state.turn!==state.human) return;
    const r=+e.currentTarget.dataset.r, c=+e.currentTarget.dataset.c;
    if(!selected){ return; }
    // find move that ends on r,c
    const move = legalForSelected.find(m=>{
      const last=m.seq[m.seq.length-1]; return last.r===r && last.c===c;
    });
    if(move){ playHumanMove(move); }
  }

  function selectSquare(r,c){
    selected = {r,c};
    allLegal = generateMoves(state.board, state.turn);
    legalForSelected = allLegal.filter(m=> m.seq[0].r===r && m.seq[0].c===c);
    // If captures exist, filter only captures
    const hasAnyCapture = allLegal.some(m=>m.captured.length>0);
    if(hasAnyCapture) legalForSelected = legalForSelected.filter(m=>m.captured.length>0);
    // If no legal moves from this piece, clear selection
    if(legalForSelected.length===0){ selected=null; }
    render();
  }

  function playHumanMove(move){
    pushHistory();
    state.board = applyMove(state.board, move);
    state.turn = -state.turn;
    selected=null; legalForSelected=[]; allLegal=[];
    render();
    checkGameOverOrAI();
  }

  function pushHistory(){
    state.history.push({ board: cloneBoard(state.board), turn: state.turn });
    if(state.history.length>200) state.history.shift();
  }

  function undo(){
    if(state.history.length===0 || state.searching) return;
    const last = state.history.pop();
    state.board = last.board; state.turn = last.turn; selected=null; legalForSelected=[]; allLegal=[]; render(); updateStatus('Undid last move.');
  }

  function checkGameOverOrAI(){
    const legal = generateMoves(state.board, state.turn);
    if(legal.length===0){
      const winner = -state.turn;
      updateStatus((winner===state.human? 'You win! 🏆' : 'AI wins. 🤖')); return;
    }
    if(state.turn!==state.human){
      aiMove();
    } else {
      updateStatus('Your move.');
    }
  }

  function aiMove(){
    state.searching = true; updateStatus('AI thinking…');
    // yield to UI thread
    setTimeout(()=>{
      const depth = state.depth;
      const { move } = search(state.board, state.turn, depth, -Infinity, Infinity);
      if(!move){ updateStatus('Stalemate.'); state.searching=false; return; }
      pushHistory();
      state.board = applyMove(state.board, move);
      state.turn = -state.turn;
      state.searching = false;
      render();
      const cap = move.captured.length>0? ` (capture x${move.captured.length})` : '';
      updateStatus('AI moved' + cap + '. Your turn.');
    }, 10);
  }

  function newGame(){
    state.board = startPosition();
    state.turn = BLACK;
    state.history = [];
    selected=null; legalForSelected=[]; allLegal=[];
    render();
    updateStatus(state.human===BLACK? 'Your move.' : 'AI to move…');
    if(state.human!==BLACK) aiMove();
  }

  // Controls
  newBtn.addEventListener('click', ()=>{ newGame(); });
  undoBtn.addEventListener('click', ()=>{ undo(); });
  sideSel.addEventListener('change', (e)=>{
    const val = +e.target.value; state.human = val; newGame();
  });
  diffSel.addEventListener('change', (e)=>{
    state.depth = +e.target.value; updateStatus(`Difficulty set to ${e.target.options[e.target.selectedIndex].text}.`);
  });

  // ---------- Test Harness ----------
  function log(msg){ testLog.textContent += msg + "\n"; }
  function assert(name, cond){
    if(cond){ log("✅ " + name); }
    else { log("❌ " + name); }
  }
  function emptyBoard(){ return [...Array(8)].map(()=>Array(8).fill(0)); }
  function place(b, r, c, p){ b[r][c]=p; }

  function runAllTests(){
    testLog.textContent = '';
    try{
      // T1: simple capture available
      let b1 = emptyBoard();
      place(b1,5,2, BLACK); place(b1,4,3, RED);
      let m1 = generateMoves(b1, BLACK);
      assert('T1: simple capture count == 1', m1.length===1 && m1[0].captured.length===1);

      // T2: king multi-capture chain (length 2 captures)
      let b2 = emptyBoard();
      place(b2,5,0, KING); place(b2,4,1, RED); place(b2,2,3, RED);
      let m2 = generateMoves(b2, BLACK);
      const hasChain = m2.some(m=> m.captured.length===2 && m.seq.length===3);
      assert('T2: king multi-capture chain exists', hasChain);

      // T3: American kinging rule ends capture immediately
      let b3 = emptyBoard();
      place(b3,2,1, BLACK); // man
      place(b3,1,2, RED);   // to jump over to (0,3) and king
      place(b3,1,4, RED);   // would be capturable if chain continued as a king, but should STOP
      let m3 = generateMoves(b3, BLACK);
      const endsOnRow0 = m3.some(m=> m.captured.length===1 && m.seq[m.seq.length-1].r===0);
      const noLongerSeq = m3.every(m=> m.captured.length===1); // no double captures after kinging
      assert('T3: capture that ends with kinging is allowed', endsOnRow0);
      assert('T3b: chain stops upon kinging (American rules)', noLongerSeq);

      // T4: start position generates finite moves without overflow
      let b4 = startPosition();
      for(let i=0;i<10;i++){ generateMoves(b4, BLACK); generateMoves(b4, RED); }
      assert('T4: repeated move generation does not overflow', true);

      log('All tests completed.');
    } catch(err){
      log('Exception in tests: '+ err.message + '\n' + (err.stack||''));
    }
  }

  if(runTestsBtn){ runTestsBtn.addEventListener('click', runAllTests); }

  // Init
  state.board = startPosition();
  render();
  updateStatus('Your move.');
  // Auto-run tests on load
  setTimeout(runAllTests, 0);
})();
</script>
</body>
</html>
